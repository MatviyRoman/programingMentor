describe("The object literal allows for new shorthands",()=>{describe("with variables",()=>{it("the short version for `{x: x}` is {x}",()=>{const e={y:2};assert.deepEqual(e,{y:2})}),it("works with multiple variables too",()=>{const e={x:1,y:2};assert.deepEqual(e,{x:1,y:2})})}),describe("with methods",()=>{const e=()=>e;it("using the name only uses it as key",()=>{const t={func:e};assert.deepEqual(t,{func:e})}),it("a different key must be given explicitly, just like before ES6",()=>{const t={otherKey:e};assert.deepEqual(t,{otherKey:e})}),it("inline functions, can written as `obj={func(){}}` instead of `obj={func:function(){}}`",()=>{const e={inlineFunc:()=>"I am inline"};assert.deepEqual(e.inlineFunc(),"I am inline")})})}),describe("Object literal properties may be computed values",()=>{it("a computed property `x` needs to be surrounded by `[]`",()=>{const e={x:1};assert.equal(e.x,1)}),it("can also get a function assigned",()=>{const e={func:()=>"seven"};assert.equal(e.func(),"seven")}),it("the key may also be the result of a function call",()=>{const e={propertyName:()=>"seven"};assert.equal(e.propertyName(),"seven")}),it("the key can also be constructed by an expression",()=>{assert("propertyName"in{propertyName:null})}),it("accessor keys can be computed names too",()=>{const e={get key(){return 1}};assert.equal(e.key,1)})}),describe("An object literal can also contain getters",()=>{it("just prefix the property with `get` (and make it a function)",(function(){const e={get x(){return"ax"}};assert.equal(e.x,"ax")})),it("must have NO parameters",(function(){const e={get x(){return"ax"}};assert.equal(e.x,"ax")})),it("can be a computed property (an expression enclosed in `[]`)",(function(){const e={get x(){return"ax"}};assert.equal(e.x,"ax")})),it("can be removed using delete",(function(){const e={get x(){return"ax"}};delete e.x,assert.equal(e.x,void 0)}))}),describe("An object literal can also contain setters",()=>{describe("defining: a setter",(function(){it("by prefixing the property with `set` (and make it a function)",(function(){let e=null;({set x(t){e=t}}).x="the new X",assert.equal(e,"the new X")})),it("must have exactly one parameter",(function(){let e=void 0;const t={set x(t){1===arguments.length&&(e=arguments[0])}};assert.equal(t.x="new value",e)})),it("can be a computed property (an expression enclosed in `[]`)",(function(){const e={set x(e){this._x=e}};e.x="axe",assert.equal(e._x,"axe")}))})),describe("working with/on the setter",(function(){it("you can use `delete` to remove the property (including it`s setter)",(function(){let e=!1;const t={set x(t){e=!0}};delete t.x,t.x=!0,assert.equal(e,!1)}))}))});