describe("a Promise represents an operation that hasn`t completed yet, but is expected in the future",(function(){it("`Promise` is a global function",(function(){assert.equal(typeof Promise,"function")})),describe("the constructor",(function(){it("instantiating it without params throws",(function(){assert.throws(()=>{new Promise})})),it("expects a function as parameter",(function(){const e=function(){};assert.doesNotThrow(()=>{new Promise(e)})}))})),describe("simplest promises",(function(){it("resolve a promise by calling the `resolve` function given as first parameter",(function(e){new Promise(e=>{e()}).then(()=>e()).catch(()=>e(new Error("The promise is expected to resolve.")))})),it("the `resolve` function can return a value, that is consumed by the `promise.then()` callback",(function(e){new Promise(e=>{e(42)}).then(t=>{assert.equal(t,42),e()}).catch(()=>e(new Error("The promise is expected to resolve with 42!")))})),it("rejecting a promise is done by calling the callback given as 2nd parameter",(function(e){new Promise(()=>{reject()}).then(()=>e(new Error("The promise is expected to be rejected."))).catch(()=>e())}))})),describe("an asynchronous promise",(function(){it("can resolve later, also by calling the first callback",(function(e){new Promise(e=>{setTimeout(()=>e(),100)}).then(()=>e()).catch(()=>e(new Error("The promise is expected to resolve.")))})),it("reject it at some later point in time, calling the 2nd callback",(function(e){new Promise((e,t)=>{setTimeout(()=>t(),100)}).then(()=>e(new Error("The promise is expected to be rejected."))).catch(()=>e())}))})),describe("test library (mocha here) support for promises",(function(){it("just returning the promise makes the test library check that the promise resolves",(function(){return new Promise((e,t)=>{e()})}))}))})),describe("A promise can be created in multiple ways",(function(){describe("creating a promise fails when",(function(){it("using `Promise` as a function",(function(){assert.throws((function(){Promise()}))})),it("no parameter is passed",(function(){assert.throws((function(){new Promise}))})),it("passing a non-callable throws too",(function(){assert.throws(()=>{new Promise(null)})}))})),describe("most commonly Promises get created using the constructor",(function(){it("by passing a resolve function to it",(function(){return new Promise((e,t)=>e())})),it("by passing a resolve and a reject function to it",(function(e){new Promise((e,t)=>t()).then(()=>e(new Error("Expected promise to be rejected."))).catch(e)}))})),describe("extending a `Promise`",(function(){it("using `class X extends Promise{}` is possible",(function(e){new class extends Promise{}(e=>e()).then(()=>e()).catch(t=>e(new Error("Expected to resolve, but failed with: "+t)))})),it("must call `super()` in the constructor if it wants to inherit/specialize the behavior",(function(){return new class extends Promise{}(e=>e())}))})),describe("`Promise.all()` returns a promise that resolves when all given promises resolve",(function(){it("returns all results",(function(e){Promise.all([new Promise(e=>e(1)),new Promise(e=>e(2))]).then(t=>{assert.deepEqual(t,[1,2]),e()}).catch(t=>e(new Error(t)))})),it("is rejected if one rejects",(function(e){Promise.all([new Promise(e=>reject(1)),new Promise(e=>e(2))]).then(()=>e(new NotRejectedError)).catch(()=>e())}))})),describe("`Promise.race()` returns the first settled promise",(function(){it("if it resolves first, the promises resolves",(function(e){const t=new Promise((e,t)=>setTimeout(t,100)),r=new Promise(e=>e("1st :)"));Promise.race([r,t]).then(t=>{assert.deepEqual(t,"1st :)"),e()}).catch(t=>e(new Error("Expected to resolve, but failed with: "+t)))})),it("if one of the given promises rejects first, the returned promise is rejected",(function(e){const t=new Promise((e,t)=>t("I am a rejector")),r=new Promise(e=>setTimeout(e,10));Promise.race([t,r]).then(()=>e(new NotRejectedError)).catch(t=>{assert.equal(t,"I am a rejector"),e()}).catch(e)}))})),describe("`Promise.resolve()` returns a resolving promise",(function(){it("if no value given, it resolves with `undefined`",(function(e){Promise.resolve().then(t=>{assert.deepEqual(t,void 0),e()}).catch(t=>e(new Error("Expected to resolve, but failed with: "+t)))})),it("resolves with the given value",(function(e){Promise.resolve("quick resolve").then(t=>{assert.equal(t,"quick resolve"),e()}).catch(t=>e(t))}))})),describe("`Promise.reject()` returns a rejecting promise",(function(){it("if no value given, it rejects with `undefined`",(function(e){Promise.reject().then(()=>e(new NotRejectedError)).catch(t=>{assert.deepEqual(t,void 0),e()}).catch(e)})),it("the parameter passed to `reject()` can be used in the `.catch()`",(function(e){Promise.reject("quick reject").then(()=>e(new NotRejectedError)).catch(t=>{assert.deepEqual(t,"quick reject"),e()}).catch(e)}))}))}));class NotRejectedError extends Error{constructor(){super(),this.message="Expected promise to be rejected."}}describe("chaining multiple promises can enhance readability",()=>{describe("prerequisites for understanding",(function(){it("reminder: the test passes when a fulfilled promise is returned",(function(){return Promise.resolve("I should fulfill.")})),it("a function given to `then()` fulfills (if it doesnt throw)",(function(){return Promise.resolve().then(()=>"I am nice").then(e=>assert.equal(e,"I am nice"))}))})),describe("chain promises",(function(){const e=e=>e.replace(/\s+/g," ");it("`then()` receives the result of the promise it was called on",(function(){return Promise.resolve("one   space     between each     word").then(t=>e(t)).then(e=>{assert.equal(e,"one space between each word")})}));const t=e=>`${e}.`;it("multiple `then()`s can be chained",(function(){Promise.resolve("Sentence without       an end").then(e).then(e=>{assert.equal(e,"Sentence without an end.")})}));const r=e=>e.replace(/^\s+/,"").replace(/\s+$/,"");it("order of the `then()`s matters",(function(){Promise.resolve("Sentence without       an end ").then(t).then(r).then(e).then(e=>{assert.equal(e,"Sentence without an end.")})}));const s=(e,t)=>{setTimeout(()=>t(e[0].toUpperCase()+e.substr(1)),100)};it("any of the things given to `then()` can resolve asynchronously (the real power of Promises)",(function(){Promise.resolve("sentence without an end").then(e=>new Promise(e=>s)).then(e=>new Promise(r=>setTimeout(()=>r(t(e)),100))).then(e=>{assert.equal(e,"Sentence without an end.")})})),it("also asynchronously, the order still matters, promises wait, but don`t block",(function(){Promise.resolve("trailing space   ").then(e=>new Promise(t=>s(e,t))).then(e=>new Promise(r=>setTimeout(()=>r(t(e)),100))).then(e=>new Promise(t=>setTimeout(()=>t(r(e)),100))).then(e=>{assert.equal(e,"Trailing space.")})}))}))}),describe("`Promise` API overview",(function(){it("`new Promise()` requires a function as param",()=>{const e=()=>{resolve()};assert.doesNotThrow(()=>{new Promise(e)})}),describe("resolving a promise",()=>{it("via constructor parameter `new Promise((resolve) => { resolve(); })`",()=>{return new Promise(e=>{e()})}),it("using `Promise.resolve()`",()=>Promise.resolve("all fine"))}),describe("a rejected promise",()=>{it("using the constructor parameter",e=>{new Promise((e,t)=>t()).then(()=>e(new Error("The promise is expected to be rejected."))).catch(()=>e())}),it("via `Promise.reject()`",e=>{Promise.reject().then(()=>e(new Error("The promise is expected to be rejected."))).catch(()=>e())})}),describe("`Promise.all()`",()=>{it("`Promise.all([p1, p2])` resolves when all promises resolve",()=>Promise.all([Promise.resolve(),Promise.resolve()])),it("`Promise.all([p1, p2])` rejects when a promise is rejected",e=>{Promise.all([Promise.reject()]).then(()=>e(new Error("The promise is expected to be rejected."))).catch(()=>e())})}),describe("`Promise.race()`",()=>{it("`Promise.race([p1, p2])` resolves/reject when one of the promises resolves/rejects",()=>{Promise.race([Promise.reject(),Promise.reject()])}),it("`Promise.race([p1, p2])` rejects when one of the promises rejects",e=>{Promise.race([Promise.reject()]).then(()=>e(new Error("The promise is expected to be rejected."))).catch(()=>e())}),it("`Promise.race([p1, p2])` order matters (and timing)",()=>Promise.race([Promise.resolve(),Promise.resolve()]))})})),describe("`catch()` returns a Promise and deals with rejected cases only",()=>{describe("prerequisites for understanding",()=>{it("*return* a fulfilled promise, to pass a test",()=>Promise.resolve()),it("reminder: the test passes when a fulfilled promise is returned",()=>Promise.resolve("I should fulfill."))}),describe("`catch` method basics",()=>{it("is an instance method",()=>{const e=Promise.reject();assert.equal(typeof e.catch,"function")}),it("catches only promise rejections",e=>{Promise.reject().then(()=>{e("Should not be called!")}).catch(e)}),it("returns a new promise",()=>{const e=()=>Promise.reject();return Promise.reject().catch(()=>e)}),it("converts it`s return value into a promise",()=>{return Promise.reject().catch(()=>"promise?").then(e=>assert.equal("promise?",e))}),it("the first parameter is the rejection reason",()=>{return Promise.reject("oops").catch(e=>{assert.equal(e,"oops")})})}),describe("multiple `catch`es",()=>{it("only the first `catch` is called",()=>{return Promise.reject("1").catch(e=>`${e} AND 2`).catch(e=>`${e} AND FOO`).then(e=>assert.equal(e,"1 AND 2"))}),it("if a `catch` throws, the next `catch` catches it",()=>{return Promise.reject("1").catch(e=>{throw Error(`${e} AND 2`)}).catch(e=>{throw Error(`${e.message} AND 3`)}).catch(e=>e.message).then(e=>assert.equal(e,"1 AND 2 AND 3"))})})});